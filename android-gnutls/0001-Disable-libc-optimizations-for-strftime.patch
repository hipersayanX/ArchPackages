--- a/src/gl/strftime.c
+++ b/src/gl/strftime.c
@@ -153,15 +153,11 @@
 #endif
 
 
-#ifdef _LIBC
 # define mktime_z(tz, tm) mktime (tm)
 # define tzname __tzname
 # define tzset __tzset
 
-# define time_t __time64_t
 # define __gmtime_r(t, tp) __gmtime64_r (t, tp)
-# define mktime(tp) __mktime64 (tp)
-#endif
 
 #if FPRINTFTIME
 # define STREAM_OR_CHAR_T FILE
--- a/src/gl/parse-datetime.y
+++ b/src/gl/parse-datetime.y
@@ -61,6 +61,8 @@
 
 #include "gettext.h"
 
+#define mktime_z(tz, tm) mktime (tm)
+
 #define _(str) gettext (str)
 
 /* Bison's skeleton tests _STDLIB_H, while some stdlib.h headers
@@ -1740,638 +1742,7 @@
                      struct timespec const *now, unsigned int flags,
                      timezone_t tzdefault, char const *tzstring)
 {
-  struct tm tm;
-  struct tm tm0;
-  char time_zone_buf[TIME_ZONE_BUFSIZE];
-  char dbg_tm[DBGBUFSIZE];
-  bool ok = false;
-  char const *input_sentinel = p + strlen (p);
-  char *tz1alloc = NULL;
-
-  /* A reasonable upper bound for the size of ordinary TZ strings.
-     Use heap allocation if TZ's length exceeds this.  */
-  enum { TZBUFSIZE = 100 };
-  char tz1buf[TZBUFSIZE];
-
-  struct timespec gettime_buffer;
-  if (! now)
-    {
-      gettime (&gettime_buffer);
-      now = &gettime_buffer;
-    }
-
-  time_t Start = now->tv_sec;
-  int Start_ns = now->tv_nsec;
-
-  unsigned char c;
-  while (c = *p, c_isspace (c))
-    p++;
-
-  timezone_t tz = tzdefault;
-
-  /* Store a local copy prior to first "goto".  Without this, a prior use
-     below of RELATIVE_TIME_0 on the RHS might translate to an assignment-
-     to-temporary, which would trigger a -Wjump-misses-init warning.  */
-  const relative_time rel_time_0 = RELATIVE_TIME_0;
-
-  if (strncmp (p, "TZ=\"", 4) == 0)
-    {
-      char const *tzbase = p + 4;
-      idx_t tzsize = 1;
-      char const *s;
-
-      for (s = tzbase; *s; s++, tzsize++)
-        if (*s == '\\')
-          {
-            s++;
-            if (! (*s == '\\' || *s == '"'))
-              break;
-          }
-        else if (*s == '"')
-          {
-            timezone_t tz1;
-            char *tz1string = tz1buf;
-            char *z;
-            if (TZBUFSIZE < tzsize)
-              {
-                tz1alloc = malloc (tzsize);
-                if (!tz1alloc)
-                  goto fail;
-                tz1string = tz1alloc;
-              }
-            z = tz1string;
-            for (s = tzbase; *s != '"'; s++)
-              *z++ = *(s += *s == '\\');
-            *z = '\0';
-            tz1 = tzalloc (tz1string);
-            if (!tz1)
-              goto fail;
-            tz = tz1;
-            tzstring = tz1string;
-
-            p = s + 1;
-            while (c = *p, c_isspace (c))
-              p++;
-
-            break;
-          }
-    }
-
-  struct tm tmp;
-  if (! localtime_rz (tz, &now->tv_sec, &tmp))
-    goto fail;
-
-  /* As documented, be careful to treat the empty string just like
-     a date string of "0".  Without this, an empty string would be
-     declared invalid when parsed during a DST transition.  */
-  if (*p == '\0')
-    p = "0";
-
-  parser_control pc;
-  pc.input = p;
-#ifdef GNULIB_PARSE_DATETIME2
-  pc.parse_datetime_debug = (flags & PARSE_DATETIME_DEBUG) != 0;
-#endif
-  if (ckd_add (&pc.year.value, tmp.tm_year, TM_YEAR_BASE))
-    {
-      if (debugging (&pc))
-        dbg_printf (_("error: initial year out of range\n"));
-      goto fail;
-    }
-  pc.year.digits = 0;
-  pc.month = tmp.tm_mon + 1;
-  pc.day = tmp.tm_mday;
-  pc.hour = tmp.tm_hour;
-  pc.minutes = tmp.tm_min;
-  pc.seconds = (struct timespec) { .tv_sec = tmp.tm_sec, .tv_nsec = Start_ns };
-  tm.tm_isdst = tmp.tm_isdst;
-
-  pc.meridian = MER24;
-  pc.rel = rel_time_0;
-  pc.timespec_seen = false;
-  pc.rels_seen = false;
-  pc.dates_seen = 0;
-  pc.days_seen = 0;
-  pc.times_seen = 0;
-  pc.J_zones_seen = 0;
-  pc.local_zones_seen = 0;
-  pc.dsts_seen = 0;
-  pc.zones_seen = 0;
-  pc.year_seen = false;
-  pc.debug_dates_seen = false;
-  pc.debug_days_seen = false;
-  pc.debug_times_seen = false;
-  pc.debug_local_zones_seen = false;
-  pc.debug_zones_seen = false;
-  pc.debug_year_seen = false;
-  pc.debug_ordinal_day_seen = false;
-
-  pc.local_time_zone_table[0].name = NULL;
-  populate_local_time_zone_table (&pc, &tmp);
-
-  /* Probe the names used in the next three calendar quarters, looking
-     for a tm_isdst different from the one we already have.  */
-  for (int quarter = 1; quarter <= 3; quarter++)
-    {
-      time_t probe;
-      if (ckd_add (&probe, Start, quarter * (90 * 24 * 60 * 60)))
-        break;
-      struct tm probe_tm;
-      if (localtime_rz (tz, &probe, &probe_tm)
-          && (! pc.local_time_zone_table[0].name
-              || probe_tm.tm_isdst != pc.local_time_zone_table[0].value))
-        {
-          populate_local_time_zone_table (&pc, &probe_tm);
-          if (pc.local_time_zone_table[1].name)
-            {
-              if (! strcmp (pc.local_time_zone_table[0].name,
-                            pc.local_time_zone_table[1].name))
-                {
-                  /* This locale uses the same abbreviation for standard and
-                     daylight times.  So if we see that abbreviation, we don't
-                     know whether it's daylight time.  */
-                  pc.local_time_zone_table[0].value = -1;
-                  pc.local_time_zone_table[1].name = NULL;
-                }
-
-              break;
-            }
-        }
-    }
-
-  if (yyparse (&pc) != 0)
-    {
-      if (debugging (&pc))
-        dbg_printf ((input_sentinel <= pc.input
-                     ? _("error: parsing failed\n")
-                     : _("error: parsing failed, stopped at '%s'\n")),
-                    pc.input);
-      goto fail;
-    }
-
-
-  /* Determine effective timezone source.  */
-
-  if (debugging (&pc))
-    {
-      dbg_printf (_("input timezone: "));
-
-      if (pc.timespec_seen)
-        fprintf (stderr, _("'@timespec' - always UTC"));
-      else if (pc.zones_seen)
-        fprintf (stderr, _("parsed date/time string"));
-      else if (tzstring)
-        {
-          if (tz != tzdefault)
-            fprintf (stderr, _("TZ=\"%s\" in date string"), tzstring);
-          else if (STREQ (tzstring, "UTC0"))
-            {
-              /* Special case: 'date -u' sets TZ="UTC0".  */
-              fprintf (stderr, _("TZ=\"UTC0\" environment value or -u"));
-            }
-          else
-            fprintf (stderr, _("TZ=\"%s\" environment value"), tzstring);
-        }
-      else
-        fprintf (stderr, _("system default"));
-
-      /* Account for DST changes if tLOCAL_ZONE was seen.
-         local timezone only changes DST and is relative to the
-         default timezone.*/
-      if (pc.local_zones_seen && !pc.zones_seen && 0 < pc.local_isdst)
-        fprintf (stderr, ", dst");
-
-      if (pc.zones_seen)
-        fprintf (stderr, " (%s)", time_zone_str (pc.time_zone, time_zone_buf));
-
-      fputc ('\n', stderr);
-    }
-
-  if (pc.timespec_seen)
-    *result = pc.seconds;
-  else
-    {
-      if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen
-               | (pc.J_zones_seen + pc.local_zones_seen + pc.zones_seen)))
-        {
-          if (debugging (&pc))
-            {
-              if (pc.times_seen > 1)
-                dbg_printf ("error: seen multiple time parts\n");
-              if (pc.dates_seen > 1)
-                dbg_printf ("error: seen multiple date parts\n");
-              if (pc.days_seen > 1)
-                dbg_printf ("error: seen multiple days parts\n");
-              if (pc.dsts_seen > 1)
-                dbg_printf ("error: seen multiple daylight-saving parts\n");
-              if ((pc.J_zones_seen + pc.local_zones_seen + pc.zones_seen) > 1)
-                dbg_printf ("error: seen multiple time-zone parts\n");
-            }
-          goto fail;
-        }
-
-      if (! to_tm_year (pc.year, debugging (&pc), &tm.tm_year)
-          || ckd_add (&tm.tm_mon, pc.month, -1)
-          || ckd_add (&tm.tm_mday, pc.day, 0))
-        {
-          if (debugging (&pc))
-            dbg_printf (_("error: year, month, or day overflow\n"));
-          goto fail;
-        }
-      if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))
-        {
-          tm.tm_hour = to_hour (pc.hour, pc.meridian);
-          if (tm.tm_hour < 0)
-            {
-              char const *mrd = (pc.meridian == MERam ? "am"
-                                 : pc.meridian == MERpm ?"pm" : "");
-              if (debugging (&pc))
-                dbg_printf (_("error: invalid hour %"PRIdMAX"%s\n"),
-                            pc.hour, mrd);
-              goto fail;
-            }
-          tm.tm_min = pc.minutes;
-          tm.tm_sec = pc.seconds.tv_sec;
-          if (debugging (&pc))
-            dbg_printf ((pc.times_seen
-                         ? _("using specified time as starting value: '%s'\n")
-                         : _("using current time as starting value: '%s'\n")),
-                        debug_strftime (&tm, dbg_tm, sizeof dbg_tm));
-        }
-      else
-        {
-          tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
-          pc.seconds.tv_nsec = 0;
-          if (debugging (&pc))
-            dbg_printf ("warning: using midnight as starting time: 00:00:00\n");
-        }
-
-      /* Let mktime deduce tm_isdst if we have an absolute timestamp.  */
-      if (pc.dates_seen | pc.days_seen | pc.times_seen)
-        tm.tm_isdst = -1;
-
-      /* But if the input explicitly specifies local time with or without
-         DST, give mktime that information.  */
-      if (pc.local_zones_seen)
-        tm.tm_isdst = pc.local_isdst;
-
-      tm0.tm_sec = tm.tm_sec;
-      tm0.tm_min = tm.tm_min;
-      tm0.tm_hour = tm.tm_hour;
-      tm0.tm_mday = tm.tm_mday;
-      tm0.tm_mon = tm.tm_mon;
-      tm0.tm_year = tm.tm_year;
-      tm0.tm_isdst = tm.tm_isdst;
-      tm.tm_wday = -1;
-
-      Start = mktime_z (tz, &tm);
-
-      if (! mktime_ok (&tm0, &tm))
-        {
-          bool repaired = false;
-          bool time_zone_seen = pc.zones_seen != 0;
-          if (time_zone_seen)
-            {
-              /* Guard against falsely reporting errors near the time_t
-                 boundaries when parsing times in other time zones.  For
-                 example, suppose the input string "1969-12-31 23:00:00 -0100",
-                 the current time zone is 8 hours ahead of UTC, and the min
-                 time_t value is 1970-01-01 00:00:00 UTC.  Then the min
-                 localtime value is 1970-01-01 08:00:00, and mktime will
-                 therefore fail on 1969-12-31 23:00:00.  To work around the
-                 problem, set the time zone to 1 hour behind UTC temporarily
-                 by setting TZ="XXX1:00" and try mktime again.  */
-
-              char tz2buf[sizeof "XXX" - 1 + TIME_ZONE_BUFSIZE];
-              tz2buf[0] = tz2buf[1] = tz2buf[2] = 'X';
-              time_zone_str (pc.time_zone, &tz2buf[3]);
-              timezone_t tz2 = tzalloc (tz2buf);
-              if (!tz2)
-                {
-                  if (debugging (&pc))
-                    dbg_printf (_("error: tzalloc (\"%s\") failed\n"), tz2buf);
-                  goto fail;
-                }
-              tm.tm_sec = tm0.tm_sec;
-              tm.tm_min = tm0.tm_min;
-              tm.tm_hour = tm0.tm_hour;
-              tm.tm_mday = tm0.tm_mday;
-              tm.tm_mon = tm0.tm_mon;
-              tm.tm_year = tm0.tm_year;
-              tm.tm_isdst = tm0.tm_isdst;
-              tm.tm_wday = -1;
-              Start = mktime_z (tz2, &tm);
-              repaired = mktime_ok (&tm0, &tm);
-              tzfree (tz2);
-            }
-
-          if (! repaired)
-            {
-              debug_mktime_not_ok (&tm0, &tm, &pc, time_zone_seen);
-              goto fail;
-            }
-        }
-
-      char dbg_ord[DBGBUFSIZE];
-
-      if (pc.days_seen && ! pc.dates_seen)
-        {
-          intmax_t dayincr;
-          tm.tm_yday = -1;
-          intmax_t day_ordinal = (pc.day_ordinal
-                                  - (0 < pc.day_ordinal
-                                     && tm.tm_wday != pc.day_number));
-          if (! (ckd_mul (&dayincr, day_ordinal, 7)
-                 || ckd_add (&dayincr, (pc.day_number - tm.tm_wday + 7) % 7,
-                             dayincr)
-                 || ckd_add (&tm.tm_mday, dayincr, tm.tm_mday)))
-            {
-              tm.tm_isdst = -1;
-              Start = mktime_z (tz, &tm);
-            }
-
-          if (tm.tm_yday < 0)
-            {
-              if (debugging (&pc))
-                dbg_printf (_("error: day '%s' "
-                              "(day ordinal=%"PRIdMAX" number=%d) "
-                              "resulted in an invalid date: '%s'\n"),
-                            str_days (&pc, dbg_ord, sizeof dbg_ord),
-                            pc.day_ordinal, pc.day_number,
-                            debug_strfdatetime (&tm, &pc, dbg_tm,
-                                                sizeof dbg_tm));
-              goto fail;
-            }
-
-          if (debugging (&pc))
-            dbg_printf (_("new start date: '%s' is '%s'\n"),
-                        str_days (&pc, dbg_ord, sizeof dbg_ord),
-                        debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));
-
-        }
-
-      if (debugging (&pc))
-        {
-          if (!pc.dates_seen && !pc.days_seen)
-            dbg_printf (_("using current date as starting value: '%s'\n"),
-                        debug_strfdate (&tm, dbg_tm, sizeof dbg_tm));
-
-          if (pc.days_seen && pc.dates_seen)
-            dbg_printf (_("warning: day (%s) ignored when explicit dates "
-                          "are given\n"),
-                        str_days (&pc, dbg_ord, sizeof dbg_ord));
-
-          dbg_printf (_("starting date/time: '%s'\n"),
-                      debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm));
-        }
-
-      /* Add relative date.  */
-      if (pc.rel.year | pc.rel.month | pc.rel.day)
-        {
-          if (debugging (&pc))
-            {
-              if ((pc.rel.year != 0 || pc.rel.month != 0) && tm.tm_mday != 15)
-                dbg_printf (_("warning: when adding relative months/years, "
-                              "it is recommended to specify the 15th of the "
-                              "months\n"));
-
-              if (pc.rel.day != 0 && tm.tm_hour != 12)
-                dbg_printf (_("warning: when adding relative days, "
-                              "it is recommended to specify noon\n"));
-            }
-
-          int year, month, day;
-          if (ckd_add (&year, tm.tm_year, pc.rel.year)
-              || ckd_add (&month, tm.tm_mon, pc.rel.month)
-              || ckd_add (&day, tm.tm_mday, pc.rel.day))
-            {
-              if (debugging (&pc))
-                dbg_printf (_("error: %s:%d\n"), __FILE__, __LINE__);
-              goto fail;
-            }
-          tm.tm_year = year;
-          tm.tm_mon = month;
-          tm.tm_mday = day;
-          tm.tm_hour = tm0.tm_hour;
-          tm.tm_min = tm0.tm_min;
-          tm.tm_sec = tm0.tm_sec;
-          tm.tm_isdst = tm0.tm_isdst;
-          tm.tm_wday = -1;
-          Start = mktime_z (tz, &tm);
-          if (tm.tm_wday < 0)
-            {
-              if (debugging (&pc))
-                dbg_printf (_("error: adding relative date resulted "
-                              "in an invalid date: '%s'\n"),
-                            debug_strfdatetime (&tm, &pc, dbg_tm,
-                                                sizeof dbg_tm));
-              goto fail;
-            }
-
-          if (debugging (&pc))
-            {
-              dbg_printf (_("after date adjustment "
-                            "(%+"PRIdMAX" years, %+"PRIdMAX" months, "
-                            "%+"PRIdMAX" days),\n"),
-                          pc.rel.year, pc.rel.month, pc.rel.day);
-              dbg_printf (_("    new date/time = '%s'\n"),
-                          debug_strfdatetime (&tm, &pc, dbg_tm,
-                                              sizeof dbg_tm));
-
-              /* Warn about crossing DST due to time adjustment.
-                 Example: https://bugs.gnu.org/8357
-                 env TZ=Europe/Helsinki \
-                   date --debug \
-                        -d 'Mon Mar 28 00:36:07 2011 EEST 1 day ago'
-
-                 This case is different than DST changes due to time adjustment,
-                 i.e., "1 day ago" vs "24 hours ago" are calculated in different
-                 places.
-
-                 'tm0.tm_isdst' contains the DST of the input date,
-                 'tm.tm_isdst' is the normalized result after calling
-                 mktime (&tm).
-              */
-              if (tm0.tm_isdst != -1 && tm.tm_isdst != tm0.tm_isdst)
-                dbg_printf (_("warning: daylight saving time changed after "
-                              "date adjustment\n"));
-
-              /* Warn if the user did not ask to adjust days but mday changed,
-                 or
-                 user did not ask to adjust months/days but the month changed.
-
-                 Example for first case:
-                 2016-05-31 + 1 month => 2016-06-31 => 2016-07-01.
-                 User asked to adjust month, but the day changed from 31 to 01.
-
-                 Example for second case:
-                 2016-02-29 + 1 year => 2017-02-29 => 2017-03-01.
-                 User asked to adjust year, but the month changed from 02 to 03.
-              */
-              if (pc.rel.day == 0
-                  && (tm.tm_mday != day
-                      || (pc.rel.month == 0 && tm.tm_mon != month)))
-                {
-                  dbg_printf (_("warning: month/year adjustment resulted in "
-                                "shifted dates:\n"));
-                  char tm_year_buf[TM_YEAR_BUFSIZE];
-                  dbg_printf (_("     adjusted Y M D: %s %02d %02d\n"),
-                              tm_year_str (year, tm_year_buf), month + 1, day);
-                  dbg_printf (_("   normalized Y M D: %s %02d %02d\n"),
-                              tm_year_str (tm.tm_year, tm_year_buf),
-                              tm.tm_mon + 1, tm.tm_mday);
-                }
-            }
-
-        }
-
-      /* The only "output" of this if-block is an updated Start value,
-         so this block must follow others that clobber Start.  */
-      if (pc.zones_seen)
-        {
-          bool overflow = false;
-#ifdef HAVE_STRUCT_TM_TM_GMTOFF
-          long int utcoff = tm.tm_gmtoff;
-#else
-          time_t t = Start;
-          struct tm gmt;
-          int utcoff = (gmtime_r (&t, &gmt)
-                        ? tm_diff (&tm, &gmt)
-                        : (overflow = true, 0));
-#endif
-          intmax_t delta;
-          overflow |= ckd_sub (&delta, pc.time_zone, utcoff);
-          time_t t1;
-          overflow |= ckd_sub (&t1, Start, delta);
-          if (overflow)
-            {
-              if (debugging (&pc))
-                dbg_printf (_("error: timezone %d caused time_t overflow\n"),
-                            pc.time_zone);
-              goto fail;
-            }
-          Start = t1;
-        }
-
-      if (debugging (&pc))
-        {
-          intmax_t Starti = Start;
-          dbg_printf (_("'%s' = %"PRIdMAX" epoch-seconds\n"),
-                      debug_strfdatetime (&tm, &pc, dbg_tm, sizeof dbg_tm),
-                      Starti);
-        }
-
-
-      /* Add relative hours, minutes, and seconds.  On hosts that support
-         leap seconds, ignore the possibility of leap seconds; e.g.,
-         "+ 10 minutes" adds 600 seconds, even if one of them is a
-         leap second.  Typically this is not what the user wants, but it's
-         too hard to do it the other way, because the time zone indicator
-         must be applied before relative times, and if mktime is applied
-         again the time zone will be lost.  */
-      {
-        intmax_t orig_ns = pc.seconds.tv_nsec;
-        intmax_t sum_ns = orig_ns + pc.rel.ns;
-        int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;
-        int d4 = (sum_ns - normalized_ns) / BILLION;
-        intmax_t d1, t1, d2, t2, t3;
-        time_t t4;
-        if (ckd_mul (&d1, pc.rel.hour, 60 * 60)
-            || ckd_add (&t1, Start, d1)
-            || ckd_mul (&d2, pc.rel.minutes, 60)
-            || ckd_add (&t2, t1, d2)
-            || ckd_add (&t3, t2, pc.rel.seconds)
-            || ckd_add (&t4, t3, d4))
-          {
-            if (debugging (&pc))
-              dbg_printf (_("error: adding relative time caused an "
-                            "overflow\n"));
-            goto fail;
-          }
-
-        result->tv_sec = t4;
-        result->tv_nsec = normalized_ns;
-
-        if (debugging (&pc)
-            && (pc.rel.hour | pc.rel.minutes | pc.rel.seconds | pc.rel.ns))
-          {
-            dbg_printf (_("after time adjustment (%+"PRIdMAX" hours, "
-                          "%+"PRIdMAX" minutes, "
-                          "%+"PRIdMAX" seconds, %+d ns),\n"),
-                        pc.rel.hour, pc.rel.minutes, pc.rel.seconds,
-                        pc.rel.ns);
-            intmax_t t4i = t4;
-            dbg_printf (_("    new time = %"PRIdMAX" epoch-seconds\n"), t4i);
-
-            /* Warn about crossing DST due to time adjustment.
-               Example: https://bugs.gnu.org/8357
-               env TZ=Europe/Helsinki           \
-               date --debug                                             \
-               -d 'Mon Mar 28 00:36:07 2011 EEST 24 hours ago'
-
-               This case is different than DST changes due to days adjustment,
-               i.e., "1 day ago" vs "24 hours ago" are calculated in different
-               places.
-
-               'tm.tm_isdst' contains the date after date adjustment.  */
-            struct tm lmt;
-            if (tm.tm_isdst != -1 && localtime_rz (tz, &result->tv_sec, &lmt)
-                && tm.tm_isdst != lmt.tm_isdst)
-              dbg_printf (_("warning: daylight saving time changed after "
-                            "time adjustment\n"));
-          }
-      }
-    }
-
-  if (debugging (&pc))
-    {
-      /* Special case: using 'date -u' simply set TZ=UTC0 */
-      if (! tzstring)
-        dbg_printf (_("timezone: system default\n"));
-      else if (STREQ (tzstring, "UTC0"))
-        dbg_printf (_("timezone: Universal Time\n"));
-      else
-        dbg_printf (_("timezone: TZ=\"%s\" environment value\n"), tzstring);
-
-      intmax_t sec = result->tv_sec;
-      int nsec = result->tv_nsec;
-      dbg_printf (_("final: %"PRIdMAX".%09d (epoch-seconds)\n"),
-                  sec, nsec);
-
-      struct tm gmt, lmt;
-      bool got_utc = !!gmtime_r (&result->tv_sec, &gmt);
-      if (got_utc)
-        dbg_printf (_("final: %s (UTC)\n"),
-                    debug_strfdatetime (&gmt, NULL,
-                                        dbg_tm, sizeof dbg_tm));
-      if (localtime_rz (tz, &result->tv_sec, &lmt))
-        {
-#ifdef HAVE_STRUCT_TM_TM_GMTOFF
-          bool got_utcoff = true;
-          long int utcoff = lmt.tm_gmtoff;
-#else
-          bool got_utcoff = got_utc;
-          int utcoff;
-          if (got_utcoff)
-            utcoff = tm_diff (&lmt, &gmt);
-#endif
-          if (got_utcoff)
-            dbg_printf (_("final: %s (UTC%s)\n"),
-                        debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm),
-                        time_zone_str (utcoff, time_zone_buf));
-          else
-            dbg_printf (_("final: %s (unknown time zone offset)\n"),
-                        debug_strfdatetime (&lmt, NULL, dbg_tm, sizeof dbg_tm));
-        }
-    }
-
-  ok = true;
-
- fail:
-  if (tz != tzdefault)
-    tzfree (tz);
-  free (tz1alloc);
-  return ok;
+  return false;
 }
 
 #ifdef GNULIB_PARSE_DATETIME2
@@ -2395,13 +1766,7 @@
 parse_datetime (struct timespec *result, char const *p,
                 struct timespec const *now)
 {
-  char const *tzstring = getenv ("TZ");
-  timezone_t tz = tzalloc (tzstring);
-  if (!tz)
     return false;
-  bool ok = parse_datetime_body (result, p, now, 0, tz, tzstring);
-  tzfree (tz);
-  return ok;
 }
 
 #if TEST
